<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>„Çà„Å£„Å°Game üêæ</title>
<link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
<style>
  /* ‚ñº‚ñº‚ñº „Éá„Ç∂„Ç§„É≥Ë®≠ÂÆö ‚ñº‚ñº‚ñº */
  body {
    margin: 0;
    font-family: 'M PLUS Rounded 1c', sans-serif;
    background-color: #fff8e7;
    background-image: radial-gradient(#fff0d0 10%, transparent 10%);
    background-size: 20px 20px;
    overflow: hidden;
    touch-action: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100dvh;
    color: #5a4a42;
    -webkit-tap-highlight-color: transparent;
    overscroll-behavior: none;
  }

  h1 { 
    margin: 10px 0; 
    font-size: 1.4rem; 
    color: #8d5524;
    text-shadow: 2px 2px 0 #fff;
    flex-shrink: 0;
    pointer-events: none;
  }

  #game-container {
      position: relative;
      border: 6px solid #e6cba8;
      border-radius: 20px;
      background: rgba(255,255,255,0.95);
      box-shadow: 0 8px 20px rgba(141, 85, 36, 0.2);
      overflow: hidden;
      touch-action: none;
  }

  canvas { display: block; }

  #next-area {
      position: absolute;
      top: 10px; right: 10px;
      width: 60px; height: 70px;
      background: #fff;
      border: 3px solid #ffb347;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      pointer-events: none;
      z-index: 10;
  }
  #next-label { font-size: 10px; font-weight: bold; color: #ffb347; margin-bottom: 2px; }
  #next-ball-preview {
      width: 35px; height: 35px;
      border-radius: 50%;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      border: 2px solid #fff8e7;
  }

  #score-board {
      position: absolute;
      top: 10px; left: 15px;
      font-size: 1.5rem;
      font-weight: bold;
      color: #ff8ba7;
      text-shadow: 1px 1px 0 #fff;
      pointer-events: none;
      z-index: 10;
  }
  #score-label { font-size: 0.8rem; color: #8d5524; }

  #loading-screen {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: #fff8e7;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
      transition: opacity 0.5s;
  }
  .spinner {
      width: 40px; height: 40px;
      border: 5px solid #e6cba8;
      border-top: 5px solid #ffb347;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
  }
  @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

  /* „Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÁîªÈù¢ */
  #game-over-screen {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(255, 248, 231, 0.9);
      display: none; /* ÊúÄÂàù„ÅØÈùûË°®Á§∫ */
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 50;
  }
  #game-over-title { font-size: 2rem; color: #ff7f7f; margin-bottom: 20px; font-weight: bold; }
  #retry-btn {
      padding: 15px 40px;
      font-size: 1.2rem;
      background: #ffb347;
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      font-family: 'M PLUS Rounded 1c', sans-serif;
      box-shadow: 0 4px 0 #e5a23d;
  }
  #retry-btn:active { transform: translateY(4px); box-shadow: none; }

  /* „Éá„É≥„Ç∏„É£„Éº„É©„Ç§„É≥ */
  #danger-line {
      position: absolute;
      top: 100px; 
      left: 0;
      width: 100%;
      height: 0;
      border-top: 3px dotted rgba(255, 100, 100, 0.4);
      pointer-events: none;
      z-index: 5;
      transition: border-color 0.2s;
  }
  /* Âç±Èô∫„Å™ÊôÇ„Å´Ëµ§„Åè„Å™„Çã„ÇØ„É©„Çπ */
  .danger-active {
      border-top: 3px solid rgba(255, 0, 0, 1) !important;
  }

</style>
</head>
<body>

<h1>üêæ „Çà„Å£„Å°Game üê∂</h1>

<div id="game-container">
    <div id="loading-screen">
        <div class="spinner"></div>
        <div>È´òÁîªË≥™Âåñ„Åó„Å¶„Çã„ÉØ„É≥...‚ú®</div>
    </div>

    <div id="game-over-screen">
        <div id="game-over-title">GAME OVER</div>
        <div style="font-size: 1.5rem; margin-bottom: 20px;">Score: <span id="final-score">0</span></div>
        <button id="retry-btn" onclick="location.reload()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÔºÅ</button>
    </div>

    <div id="score-board">
        <span id="score-label">Score</span><br>
        <span id="score">0</span>
    </div>
    
    <div id="next-area">
        <div id="next-label">NEXT</div>
        <div id="next-ball-preview"></div>
    </div>
    
    <div id="danger-line"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

<script>
  // ‚ñº‚ñº‚ñº „Çµ„Ç§„Ç∫ÊØîÁéáË®≠ÂÆöÔºàÊú¨ÂÆ∂‰ªïÊßòÔºâ ‚ñº‚ñº‚ñº
  const SIZE_RATIOS = [
      0.10, // Lv1: „Åï„Åè„Çâ„Çì„Åº (10%)
      0.13, // Lv2: „ÅÑ„Å°„Åî
      0.16, // Lv3: „Å∂„Å©„ÅÜ
      0.19, // Lv4: „Éá„Ç≥„Éù„É≥
      0.23, // Lv5: „Åã„Åç
      0.28, // Lv6: „Çä„Çì„Åî
      0.33, // Lv7: „Å™„Åó
      0.40, // Lv8: „ÇÇ„ÇÇ
      0.48, // Lv9: „Éë„Ç§„Éä„ÉÉ„Éó„É´
      0.53, // Lv10: „É°„É≠„É≥
      0.58  // Lv11: „Çπ„Ç§„Ç´
  ];

  const FRUIT_IMAGES = [
      '1.png', '2.png', '3.png', '4.png', '5.png', '6.png', 
      '7.png', '8.png', '9.png', '10.png', '11.png'
  ];

  const { Engine, Render, Runner, World, Bodies, Body, Events } = Matter;

  let engine, render, runner;
  let currentBall = null;
  let nextLevelIndex = 0;
  let canDrop = false;
  let isDragging = false;
  let score = 0;
  let gameWidth, gameHeight;
  let isGameOver = false;
  let dangerTimer = 0; // „Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÂà§ÂÆöÁî®„Çø„Ç§„Éû„Éº
  
  let fruitLevels = [];
  const circularImages = {}; 

  const container = document.getElementById('game-container');
  const scoreEl = document.getElementById('score');
  const nextPreviewEl = document.getElementById('next-ball-preview');
  const loadingScreen = document.getElementById('loading-screen');
  const gameOverScreen = document.getElementById('game-over-screen');
  const finalScoreEl = document.getElementById('final-score');
  const dangerLineEl = document.getElementById('danger-line');

  // --- 1. ÁîªÈù¢„Çµ„Ç§„Ç∫Ë®àÁÆó (2:3) ---
  function calculateGameSize() {
      const maxWidth = Math.min(window.innerWidth * 0.95, 450);
      const maxHeight = window.innerHeight * 0.85;

      let w = maxWidth;
      let h = w * 1.5;

      if (h > maxHeight) {
          h = maxHeight;
          w = h / 1.5;
      }

      gameWidth = w;
      gameHeight = h;

      container.style.width = `${gameWidth}px`;
      container.style.height = `${gameHeight}px`;

      fruitLevels = SIZE_RATIOS.map((ratio, index) => {
          return {
              level: index + 1,
              radius: (gameWidth * ratio) / 2,
              img: FRUIT_IMAGES[index]
          };
      });
  }

  // --- 2. ÁîªÂÉèÂá¶ÁêÜÔºàÈ´òÁîªË≥™Âåñ 3ÂÄç„Ç∫„Éº„É†Ôºâ ---
  async function preloadAndCropImages() {
      calculateGameSize();

      const promises = fruitLevels.map((fruit, index) => {
          return new Promise((resolve) => {
              const img = new Image();
              img.crossOrigin = "Anonymous";
              img.src = fruit.img;
              
              img.onload = () => {
                  // ‚ñº‚ñº‚ñº ÁîªË≥™„Ç¢„ÉÉ„Éó„ÅÆÁßòË®£ÔºöËß£ÂÉèÂ∫¶„Çí3ÂÄç„Åß‰ΩúÊàê„Åô„Çã ‚ñº‚ñº‚ñº
                  const scaleFactor = 3; 
                  const targetRadius = fruit.radius * scaleFactor;
                  const canvasSize = targetRadius * 2;
                  
                  const canvas = document.createElement('canvas');
                  canvas.width = canvasSize;
                  canvas.height = canvasSize;
                  const ctx = canvas.getContext('2d');

                  ctx.beginPath();
                  ctx.arc(canvasSize/2, canvasSize/2, canvasSize/2, 0, Math.PI * 2);
                  ctx.closePath();
                  ctx.clip(); 

                  const sourceSize = Math.min(img.width, img.height);
                  const sx = (img.width - sourceSize) / 2;
                  const sy = (img.height - sourceSize) / 2;

                  ctx.drawImage(img, sx, sy, sourceSize, sourceSize, 0, 0, canvasSize, canvasSize);

                  circularImages[index] = canvas.toDataURL();
                  resolve();
              };
              img.onerror = () => {
                  circularImages[index] = null;
                  resolve();
              };
          });
      });
      
      await Promise.all(promises);
      
      loadingScreen.style.opacity = 0;
      setTimeout(() => {
          loadingScreen.style.display = 'none';
          initGame();
      }, 500);
  }

  // --- 3. „Ç≤„Éº„É†ÂàùÊúüÂåñ ---
  function initGame() {
      engine = Engine.create();
      engine.world.gravity.y = 0.8; // ‚ñº‚ñº‚ñº ÈáçÂäõÂº±„ÇÅÔºà„Åµ„Çè„Å£„Å®Ôºâ ‚ñº‚ñº‚ñº

      render = Render.create({
          element: container,
          engine: engine,
          options: {
              width: gameWidth,
              height: gameHeight,
              wireframes: false,
              background: 'transparent',
              pixelRatio: window.devicePixelRatio
          }
      });

      const wallThickness = 500;
      const walls = [
          Bodies.rectangle(gameWidth/2, gameHeight + wallThickness/2, gameWidth + wallThickness*2, wallThickness, { isStatic: true, render: { fillStyle: '#e6cba8' } }),
          Bodies.rectangle(-wallThickness/2, gameHeight/2, wallThickness, gameHeight*2, { isStatic: true, render: { opacity: 0 } }),
          Bodies.rectangle(gameWidth + wallThickness/2, gameHeight/2, wallThickness, gameHeight*2, { isStatic: true, render: { opacity: 0 } })
      ];
      World.add(engine.world, walls);

      Render.run(render);
      runner = Runner.create();
      Runner.run(runner, engine);
      
      Events.on(engine, 'collisionStart', handleCollision);
      // ‚ñº‚ñº‚ñº „Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÁõ£Ë¶ñ„É´„Éº„Éó ‚ñº‚ñº‚ñº
      Events.on(engine, 'afterUpdate', checkGameOver);

      updateNextBall();
      spawnReadyBall();
  }

  // --- 4. „Éú„Éº„É´‰ΩúÊàê ---
  function createFruit(x, y, index, isStatic = false) {
      const fruit = fruitLevels[index];
      const texture = circularImages[index];

      return Bodies.circle(x, y, fruit.radius, {
          isStatic: isStatic,
          label: 'fruit_' + index,
          restitution: 0.2,
          friction: 0.1, 
          density: 0.001,
          render: {
              sprite: texture ? {
                  texture: texture,
                  // ‚ñº‚ñº‚ñº 3ÂÄç„Åß‰Ωú„Å£„ÅüÁîªÂÉè„Çí1/3„Å´Á∏ÆÂ∞èË°®Á§∫Ôºà„Åì„Çå„ÅßÈ´òÁîªË≥™ÔºÅÔºâ ‚ñº‚ñº‚ñº
                  xScale: 1 / 3, 
                  yScale: 1 / 3
              } : { fillStyle: '#ffb347' } 
          }
      });
  }

  function updateNextBall() {
      nextLevelIndex = Math.floor(Math.random() * 5);
      const texture = circularImages[nextLevelIndex];
      if (texture) {
          nextPreviewEl.style.backgroundImage = `url(${texture})`;
          nextPreviewEl.style.backgroundColor = 'transparent';
      } else {
          nextPreviewEl.style.backgroundImage = 'none';
          nextPreviewEl.style.backgroundColor = '#ffb347';
      }
  }

  function spawnReadyBall() {
      if (currentBall || isGameOver) return;
      currentBall = createFruit(gameWidth/2, 50, nextLevelIndex, true);
      currentBall.collisionFilter = { group: -1, category: 0x0002, mask: 0x0000 }; 
      World.add(engine.world, currentBall);
      canDrop = true;
      isDragging = false;
  }

  // --- 5. Êìç‰Ωú ---
  
  const handleStart = (e) => {
      if (!canDrop || !currentBall || isGameOver) return;
      e.preventDefault();
      isDragging = true;
      moveBall(e);
  };

  const handleMove = (e) => {
      if (!canDrop || !currentBall || !isDragging || isGameOver) return;
      e.preventDefault();
      moveBall(e);
  };

  const handleEnd = (e) => {
      if (!canDrop || !currentBall || !isDragging || isGameOver) return;
      e.preventDefault();
      isDragging = false;
      dropBall();
  };

  function moveBall(e) {
      let clientX;
      if (e.type.startsWith('touch')) {
          clientX = e.touches[0].clientX;
      } else {
          clientX = e.clientX;
      }
      const rect = container.getBoundingClientRect();
      const x = clientX - rect.left;
      const fruit = fruitLevels[nextLevelIndex];
      const minX = fruit.radius + 5;
      const maxX = gameWidth - fruit.radius - 5;
      const clampedX = Math.max(minX, Math.min(maxX, x));
      Body.setPosition(currentBall, { x: clampedX, y: 50 });
  }

  function dropBall() {
      Body.setStatic(currentBall, false);
      currentBall.collisionFilter = { group: 0, category: 0x0001, mask: 0xFFFFFFFF };
      currentBall = null;
      canDrop = false;
      updateNextBall();
      setTimeout(spawnReadyBall, 600);
  }

  container.addEventListener('touchstart', handleStart, { passive: false });
  container.addEventListener('touchmove', handleMove, { passive: false });
  container.addEventListener('touchend', handleEnd, { passive: false });
  container.addEventListener('mousedown', handleStart);
  window.addEventListener('mousemove', handleMove);
  window.addEventListener('mouseup', handleEnd);

  // --- 6. Âêà‰Ωì ---
  function handleCollision(event) {
      if (isGameOver) return;
      const pairs = event.pairs;
      for (let i = 0; i < pairs.length; i++) {
          const bodyA = pairs[i].bodyA;
          const bodyB = pairs[i].bodyB;

          if (bodyA.label.startsWith('fruit_') && bodyB.label === bodyA.label) {
              const level = parseInt(bodyA.label.split('_')[1]);

              if (level < fruitLevels.length - 1) {
                  const midX = (bodyA.position.x + bodyB.position.x) / 2;
                  const midY = (bodyA.position.y + bodyB.position.y) / 2;

                  World.remove(engine.world, [bodyA, bodyB]);
                  const newBall = createFruit(midX, midY, level + 1);
                  World.add(engine.world, newBall);

                  score += (level + 1) * 2;
                  scoreEl.textContent = score;
                  break; 
              }
          }
      }
  }

  // --- 7. „Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÂà§ÂÆö ---
  function checkGameOver() {
      if (isGameOver) return;

      const bodies = Composite.allBodies(engine.world);
      const dangerY = 100; // ÁÇπÁ∑ö„ÅÆYÂ∫ßÊ®ô
      let isDanger = false;

      // ÊâãÊåÅ„Å°„ÅÆ„Éú„Éº„É´‰ª•Â§ñ„Åß„ÄÅ„É©„Ç§„É≥„ÇíË∂Ö„Åà„Å¶„ÅÑ„Çã„ÇÇ„ÅÆ„ÇíÊé¢„Åô
      for (const body of bodies) {
          if (!body.isStatic && body !== currentBall) {
              // Âà§ÂÆö„ÇíÂé≥„Åó„ÅèÔºöÂçäÂæÑ„ÅÆÂçäÂàÜ‰ª•‰∏ä„ÅØ„ÅøÂá∫„Åó„Åü„Çâ„Ç¢„Ç¶„Éà
              if (body.position.y - body.circleRadius * 0.5 < dangerY) {
                  isDanger = true;
                  break;
              }
          }
      }

      if (isDanger) {
          dangerLineEl.classList.add('danger-active'); // Á∑ö„ÇíËµ§„Åè
          dangerTimer++;
          
          // 60fps * 3Áßí = 180„Éï„É¨„Éº„É†
          if (dangerTimer > 180) {
              gameOver();
          }
      } else {
          dangerLineEl.classList.remove('danger-active');
          dangerTimer = 0; // Ëß£Èô§„Åï„Çå„Åü„Çâ„É™„Çª„ÉÉ„Éà
      }
  }

  function gameOver() {
      isGameOver = true;
      Runner.stop(runner); // Áâ©ÁêÜÊºîÁÆó„Çπ„Éà„ÉÉ„Éó
      finalScoreEl.innerText = score;
      gameOverScreen.style.display = 'flex';
  }

  preloadAndCropImages();

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>„Çà„Å°GAME ‚ù§Ô∏è</title>
<link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
<style>
  /* ‚ñº‚ñº‚ñº „Éá„Ç∂„Ç§„É≥Ë®≠ÂÆöÔºà„Éë„Çπ„ÉÜ„É´„Éî„É≥„ÇØÔºÜ„Éñ„É´„ÉºÔºâ ‚ñº‚ñº‚ñº */
  body {
    margin: 0;
    font-family: 'M PLUS Rounded 1c', sans-serif;
    /* ËÉåÊôØËâ≤ÔºöËñÑ„ÅÑ„Éî„É≥„ÇØ */
    background-color: #fff0f5;
    background-image: url('bg.jpg');
    background-size: cover;
    background-position: center bottom;
    background-repeat: no-repeat;
    overflow: hidden;
    touch-action: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100dvh;
    color: #5a4a42;
    -webkit-tap-highlight-color: transparent;
    overscroll-behavior: none;
  }

  h1 { 
    margin: 5px 0; 
    font-size: 1.4rem; 
    color: #fff; 
    /* ÂΩ±Ôºö„Éë„Çπ„ÉÜ„É´„Éñ„É´„Éº„Å®„Éî„É≥„ÇØ„ÅÆ„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥È¢® */
    text-shadow: 2px 2px 0 #87cefa, -1px -1px 0 #ffb6c1, 1px -1px 0 #87cefa, -1px 1px 0 #ffb6c1, 1px 1px 0 #87cefa;
    flex-shrink: 0;
    pointer-events: none;
    z-index: 10;
  }

  /* „Ç≤„Éº„É†Êû† */
  #game-container {
      position: relative;
      width: 90vw; 
      height: 70dvh; 
      max-width: 450px;
      max-height: 800px;
      /* Êû†Á∑öÔºö„Éë„Çπ„ÉÜ„É´„Éî„É≥„ÇØ */
      border: 6px solid #ffb6c1;
      border-radius: 20px;
      background: rgba(255, 255, 255, 0.6);
      box-shadow: 0 8px 20px rgba(135, 206, 250, 0.4); /* ÂΩ±„ÅØÊ∞¥Ëâ≤„ÅßÁàΩ„ÇÑ„Åã„Å´ */
      overflow: visible; 
      touch-action: none;
  }

  canvas { display: block; }

  /* „Éó„É¨„Ç§„É§„Éº„Ç≠„É£„É© (cloud.png 1Êûö„ÅßÂØæÂøú) */
  #cloud-char {
      position: absolute;
      top: -45px; /* Êâã„ÅÆ‰ΩçÁΩÆË™øÊï¥„ÅÆ„Åü„ÇÅÂ∞ë„Åó‰∏ä„Åí„Åæ„Åó„Åü */
      left: 50%;
      transform: translateX(-50%);
      width: 150px; 
      height: 100px; /* Â∞ë„ÅóÁ∏¶Èï∑„Å´Á¢∫‰øù */
      background-image: url('cloud.png');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center bottom;
      filter: drop-shadow(0 5px 5px rgba(0,0,0,0.2));
      display: none; 
      z-index: 20;
      pointer-events: none;
  }

  /* Ë°ùÊíÉÊ≥¢„Ç®„Éï„Çß„ÇØ„Éà */
  .shockwave {
      position: absolute;
      border-radius: 50%;
      border: 4px solid rgba(255, 182, 193, 0.8);
      background: transparent;
      transform: translate(-50%, -50%);
      pointer-events: none;
      animation: pop 0.4s ease-out forwards;
      z-index: 5;
  }
  @keyframes pop {
      0% { transform: translate(-50%, -50%) scale(0.8); opacity: 1; border-width: 10px; }
      100% { transform: translate(-50%, -50%) scale(1.8); opacity: 0; border-width: 0px; }
  }

  /* UIÂÖ±ÈÄö„Çπ„Çø„Ç§„É´ */
  .ui-box {
      position: absolute;
      background: rgba(255, 255, 255, 0.8);
      /* Êû†Á∑öÔºö„Éë„Çπ„ÉÜ„É´„Éñ„É´„Éº */
      border: 3px solid #87cefa;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      pointer-events: none;
      z-index: 10;
  }

  #next-area { top: 10px; right: 10px; width: 60px; height: 70px; }
  #next-label { font-size: 10px; font-weight: bold; color: #87cefa; margin-bottom: 2px; }
  #next-ball-preview {
      width: 35px; height: 35px;
      border-radius: 50%;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      border: 2px solid #fff;
  }

  #score-board { top: 10px; left: 15px; border: none; background: none; box-shadow: none; align-items: flex-start; }
  #score-board .score-text { font-size: 1.5rem; font-weight: bold; color: #ff69b4; text-shadow: 1px 1px 0 #fff; }
  #score-label { font-size: 0.8rem; color: #5a4a42; }

  /* „Ç™„Éº„Éê„Éº„É¨„Ç§ÁîªÈù¢ */
  .overlay {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 50;
      border-radius: 15px;
  }
  #loading-screen { background: #fff0f5; z-index: 100; transition: opacity 0.5s; }
  #game-over-screen { background: rgba(255, 240, 245, 0.95); display: none; }

  .spinner {
      width: 40px; height: 40px;
      border: 5px solid #ffb6c1;
      border-top: 5px solid #87cefa;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
  }
  @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

  #game-over-title { font-size: 2rem; color: #ff69b4; margin-bottom: 20px; font-weight: bold; }
  #retry-btn {
      padding: 15px 40px;
      font-size: 1.2rem;
      background: #87cefa;
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      font-family: 'M PLUS Rounded 1c', sans-serif;
      box-shadow: 0 4px 0 #4682b4;
  }
  #retry-btn:active { transform: translateY(4px); box-shadow: none; }

  #danger-line {
      position: absolute;
      top: 20%; left: 0; width: 100%; height: 0;
      border-top: 3px dotted rgba(255, 105, 180, 0.5);
      pointer-events: none;
      z-index: 5;
      transition: border-color 0.2s;
  }
  .danger-active { border-top: 3px solid rgba(255, 20, 147, 1) !important; }
</style>
</head>
<body>

<h1>‚ù§Ô∏è „Çà„Å°GAME üê∂</h1>

<div id="game-container">
    <div id="loading-screen" class="overlay">
        <div class="spinner"></div>
        <div>Ê∫ñÂÇô‰∏≠„Å†„Çà...üíï</div>
    </div>

    <div id="game-over-screen" class="overlay">
        <div id="game-over-title">GAME OVER</div>
        <div style="font-size: 1.5rem; margin-bottom: 20px;">Score: <span id="final-score">0</span></div>
        <button id="retry-btn" onclick="location.reload()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÔºÅ</button>
    </div>

    <div id="score-board" class="ui-box">
        <span id="score-label">Score</span>
        <span id="score" class="score-text">0</span>
    </div>
    
    <div id="next-area" class="ui-box">
        <div id="next-label">NEXT</div>
        <div id="next-ball-preview"></div>
    </div>
    
    <div id="danger-line"></div>
    <div id="cloud-char"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

<script>
  /**
   * ==========================================
   * CONFIG: „Ç≤„Éº„É†Ë®≠ÂÆö
   * ==========================================
   */
  const CONFIG = {
      ASPECT_RATIO: 1.4,
      WIDTH_PCT: 0.90,
      SPAWN_Y_OFFSET: 80,
      DANGER_LINE_PCT: 0.2,
      GRAVITY: 0.58,
      FRICTION: 0.01,
      RESTITUTION: 0.15,
      AIR_FRICTION: 0.001,
      ITERATIONS: 10,
      NEXT_QUEUE_RANGE: 5,
      GAME_OVER_TIME: 180,
      SIZE_RATIOS: [0.068, 0.093, 0.125, 0.137, 0.175, 0.206, 0.237, 0.312, 0.375, 0.481, 0.600],
      // „Éë„Çπ„ÉÜ„É´Á≥ª„Ç´„É©„ÉºÊû†
      BORDER_COLORS: ['#ffb6c1', '#87cefa', '#dda0dd', '#ffdab9', '#98fb98', '#ff69b4', '#00bfff', '#ffc0cb', '#adebad', '#ff1493', '#4169e1'],
      IMAGES: ['1.png', '2.png', '3.png', '4.png', '5.png', '6.png', '7.png', '8.png', '9.png', '10.png', '11.png']
  };

  const State = {
      engine: null, render: null, runner: null,
      currentBall: null, currLevelIndex: 0, nextLevelIndex: 0,
      canDrop: false, isDragging: false, touchId: null,
      score: 0, gameWidth: 0, gameHeight: 0,
      isGameOver: false, dangerTimer: 0,
      audioCtx: null, circularImages: {}, fruitProps: []
  };

  const { Engine, Render, Runner, World, Bodies, Body, Events, Composite } = Matter;

  const DOM = {
      container: document.getElementById('game-container'),
      score: document.getElementById('score'),
      nextPreview: document.getElementById('next-ball-preview'),
      loading: document.getElementById('loading-screen'),
      gameOver: document.getElementById('game-over-screen'),
      finalScore: document.getElementById('final-score'),
      dangerLine: document.getElementById('danger-line'),
      cloudChar: document.getElementById('cloud-char')
  };

  function initAudio() {
      if (!State.audioCtx) {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          State.audioCtx = new AudioContext();
      }
      if (State.audioCtx.state === 'suspended') State.audioCtx.resume();
  }

  function playSound(type, level = 0) {
      if (!State.audioCtx) return;
      const osc = State.audioCtx.createOscillator();
      const gain = State.audioCtx.createGain();
      osc.connect(gain);
      gain.connect(State.audioCtx.destination);
      const now = State.audioCtx.currentTime;

      if (type === 'drop') {
          osc.type = 'sine';
          osc.frequency.setValueAtTime(800, now);
          osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
          gain.gain.setValueAtTime(0.1, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
          osc.start(now); osc.stop(now + 0.15);
      } else if (type === 'merge') {
          osc.type = 'triangle';
          const baseFreq = 440 + (level * 80);
          osc.frequency.setValueAtTime(baseFreq, now);
          osc.frequency.linearRampToValueAtTime(baseFreq * 1.5, now + 0.1);
          gain.gain.setValueAtTime(0.1, now);
          gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
          osc.start(now); osc.stop(now + 0.2);
      }
  }

  async function init() {
      calculateLayout();
      const timeout = new Promise(resolve => setTimeout(resolve, 3000));
      const imageLoad = preloadImages();
      await Promise.race([imageLoad, timeout]);
      setupPhysics();
      setupEvents();
      startGame();
  }

  function calculateLayout() {
      const maxWidth = Math.min(window.innerWidth * CONFIG.WIDTH_PCT, 450);
      const maxHeight = window.innerHeight * 0.85;
      let w = maxWidth;
      let h = w * CONFIG.ASPECT_RATIO;
      if (h > maxHeight) { h = maxHeight; w = h / CONFIG.ASPECT_RATIO; }

      State.gameWidth = w;
      State.gameHeight = h;
      DOM.container.style.width = `${w}px`;
      DOM.container.style.height = `${h}px`;
      DOM.cloudChar.style.top = `${-40}px`; // ÁîªÂÉè„Å´Âêà„Çè„Åõ„Å¶Ë™øÊï¥

      State.fruitProps = CONFIG.SIZE_RATIOS.map((ratio, index) => ({
          level: index + 1,
          radius: (w * ratio) / 2,
          img: CONFIG.IMAGES[index],
          color: CONFIG.BORDER_COLORS[index]
      }));
  }

  function preloadImages() {
      const promises = State.fruitProps.map((fruit, index) => {
          return new Promise((resolve) => {
              const img = new Image();
              img.crossOrigin = "Anonymous";
              img.src = fruit.img;
              img.onload = () => {
                  const scaleFactor = 3; 
                  const targetRadius = fruit.radius * scaleFactor;
                  const canvasSize = targetRadius * 2;
                  const borderWidth = targetRadius * 0.05;
                  
                  const canvas = document.createElement('canvas');
                  canvas.width = canvasSize;
                  canvas.height = canvasSize;
                  const ctx = canvas.getContext('2d');
                  ctx.beginPath();
                  ctx.arc(canvasSize/2, canvasSize/2, canvasSize/2, 0, Math.PI * 2);
                  ctx.closePath();
                  ctx.clip();
                  const sSize = Math.min(img.width, img.height);
                  ctx.drawImage(img, (img.width-sSize)/2, (img.height-sSize)/2, sSize, sSize, 0, 0, canvasSize, canvasSize);
                  ctx.beginPath();
                  ctx.arc(canvasSize/2, canvasSize/2, canvasSize/2 - borderWidth/2, 0, Math.PI * 2);
                  ctx.lineWidth = borderWidth;
                  ctx.strokeStyle = fruit.color;
                  ctx.stroke();
                  State.circularImages[index] = canvas.toDataURL();
                  resolve();
              };
              img.onerror = () => resolve(); 
          });
      });
      return Promise.all(promises);
  }

  function setupPhysics() {
      State.engine = Engine.create();
      State.engine.world.gravity.y = CONFIG.GRAVITY;
      State.engine.positionIterations = CONFIG.ITERATIONS;
      State.engine.velocityIterations = CONFIG.ITERATIONS;

      State.render = Render.create({
          element: DOM.container,
          engine: State.engine,
          options: {
              width: State.gameWidth,
              height: State.gameHeight,
              wireframes: false,
              background: 'transparent',
              pixelRatio: window.devicePixelRatio
          }
      });

      const wallThick = 500;
      const walls = [
          Bodies.rectangle(State.gameWidth/2, State.gameHeight + wallThick/2, State.gameWidth + wallThick*2, wallThick, { isStatic: true, render: { fillStyle: '#ffb6c1' } }),
          Bodies.rectangle(-wallThick/2, State.gameHeight/2, wallThick, State.gameHeight*2, { isStatic: true, render: { opacity: 0 } }),
          Bodies.rectangle(State.gameWidth + wallThick/2, State.gameHeight/2, wallThick, State.gameHeight*2, { isStatic: true, render: { opacity: 0 } })
      ];
      World.add(State.engine.world, walls);

      Events.on(State.engine, 'collisionStart', handleCollision);
      Events.on(State.engine, 'afterUpdate', checkGameOver);
  }

  function setupEvents() {
      const onStart = (e) => {
          initAudio();
          if (!State.canDrop || !State.currentBall || State.isGameOver) return;
          e.preventDefault();
          if (State.isDragging) return;
          if (e.type === 'touchstart') {
              State.touchId = e.changedTouches[0].identifier;
          }
          State.isDragging = true;
          moveBall(e);
      };
      const onMove = (e) => {
          if (!State.canDrop || !State.currentBall || !State.isDragging || State.isGameOver) return;
          e.preventDefault();
          moveBall(e);
      };
      const onEnd = (e) => {
          if (!State.canDrop || !State.currentBall || !State.isDragging || State.isGameOver) return;
          e.preventDefault();
          if (e.type === 'touchend') {
              let isTarget = false;
              for (let i = 0; i < e.changedTouches.length; i++) {
                  if (e.changedTouches[i].identifier === State.touchId) { isTarget = true; break; }
              }
              if (!isTarget) return;
          }
          State.isDragging = false;
          State.touchId = null;
          dropBall();
      };
      DOM.container.addEventListener('touchstart', onStart, { passive: false });
      DOM.container.addEventListener('touchmove', onMove, { passive: false });
      DOM.container.addEventListener('touchend', onEnd, { passive: false });
      DOM.container.addEventListener('mousedown', onStart);
      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onEnd);
  }

  function startGame() {
      DOM.loading.style.opacity = 0;
      setTimeout(() => DOM.loading.style.display = 'none', 500);
      Render.run(State.render);
      State.runner = Runner.create();
      Runner.run(State.runner, State.engine);
      State.currLevelIndex = Math.floor(Math.random() * CONFIG.NEXT_QUEUE_RANGE);
      State.nextLevelIndex = Math.floor(Math.random() * CONFIG.NEXT_QUEUE_RANGE);
      updateNextView();
      spawnReadyBall();
  }

  function createFruit(x, y, index, isStatic = false) {
      const fruit = State.fruitProps[index];
      const texture = State.circularImages[index];
      return Bodies.circle(x, y, fruit.radius, {
          isStatic: isStatic,
          label: 'fruit_' + index,
          restitution: CONFIG.RESTITUTION,
          friction: CONFIG.FRICTION,
          frictionAir: CONFIG.AIR_FRICTION,
          render: {
              sprite: texture ? { texture: texture, xScale: 1/3, yScale: 1/3 } : { fillStyle: fruit.color }
          }
      });
  }

  function spawnReadyBall() {
      if (State.currentBall || State.isGameOver) return;
      State.currentBall = createFruit(State.gameWidth/2, CONFIG.SPAWN_Y_OFFSET, State.currLevelIndex, true);
      State.currentBall.collisionFilter = { group: -1, category: 0x0002, mask: 0x0000 };
      World.add(State.engine.world, State.currentBall);
      State.canDrop = true;
      DOM.cloudChar.style.display = 'block';
      updateCloudPos(State.gameWidth/2);
  }

  function moveBall(e) {
      let cx;
      if (e.type.startsWith('touch')) {
          for (let i = 0; i < e.touches.length; i++) {
              if (e.touches[i].identifier === State.touchId) { cx = e.touches[i].clientX; break; }
          }
          if (cx === undefined) return;
      } else { cx = e.clientX; }

      const rect = DOM.container.getBoundingClientRect();
      const x = cx - rect.left;
      const fruit = State.fruitProps[State.currLevelIndex];
      const minX = fruit.radius + 2;
      const maxX = State.gameWidth - fruit.radius - 2;
      const clampedX = Math.max(minX, Math.min(maxX, x));

      Body.setPosition(State.currentBall, { x: clampedX, y: CONFIG.SPAWN_Y_OFFSET });
      updateCloudPos(clampedX);
  }

  function updateCloudPos(x) {
      DOM.cloudChar.style.left = `${x}px`;
  }

  function dropBall() {
      playSound('drop');
      Body.setStatic(State.currentBall, false);
      State.currentBall.collisionFilter = { group: 0, category: 0x0001, mask: 0xFFFFFFFF };
      State.currentBall = null;
      State.canDrop = false;
      DOM.cloudChar.style.display = 'none';
      State.currLevelIndex = State.nextLevelIndex;
      State.nextLevelIndex = Math.floor(Math.random() * CONFIG.NEXT_QUEUE_RANGE);
      updateNextView();
      setTimeout(spawnReadyBall, 600);
  }

  function updateNextView() {
      const texture = State.circularImages[State.nextLevelIndex];
      if (texture) {
          DOM.nextPreview.style.backgroundImage = `url(${texture})`;
          DOM.nextPreview.style.backgroundColor = 'transparent';
      } else {
          DOM.nextPreview.style.backgroundImage = 'none';
          DOM.nextPreview.style.backgroundColor = '#87cefa';
      }
  }

  function createShockwave(x, y, radius) {
      const wave = document.createElement('div');
      wave.className = 'shockwave';
      wave.style.left = `${x}px`;
      wave.style.top = `${y}px`;
      wave.style.width = `${radius * 2}px`;
      wave.style.height = `${radius * 2}px`;
      DOM.container.appendChild(wave);
      setTimeout(() => wave.remove(), 400);
  }

  function handleCollision(event) {
      if (State.isGameOver) return;
      const pairs = event.pairs;
      const processedBodies = new Set();

      for (let i = 0; i < pairs.length; i++) {
          const { bodyA, bodyB } = pairs[i];
          if (processedBodies.has(bodyA.id) || processedBodies.has(bodyB.id)) continue;

          if (bodyA.label.startsWith('fruit_') && bodyB.label === bodyA.label) {
              const level = parseInt(bodyA.label.split('_')[1]);
              if (level < State.fruitProps.length - 1) {
                  processedBodies.add(bodyA.id);
                  processedBodies.add(bodyB.id);
                  World.remove(State.engine.world, [bodyA, bodyB]);
                  
                  const lower = (bodyA.position.y > bodyB.position.y) ? bodyA : bodyB;
                  const newBall = createFruit(lower.position.x, lower.position.y, level + 1);
                  World.add(State.engine.world, newBall);
                  
                  createShockwave(lower.position.x, lower.position.y, newBall.circleRadius);
                  playSound('merge', level);
                  
                  const pts = (level + 1) * (level + 2) / 2;
                  State.score += pts;
                  DOM.score.textContent = State.score;
              }
          }
      }
  }

  function checkGameOver() {
      if (State.isGameOver) return;
      const bodies = Composite.allBodies(State.engine.world);
      const dangerY = State.gameHeight * CONFIG.DANGER_LINE_PCT;
      DOM.dangerLine.style.top = `${dangerY}px`;

      let isDanger = false;
      for (const body of bodies) {
          if (!body.isStatic && body !== State.currentBall) {
              if (body.position.y - body.circleRadius * 0.5 < dangerY) {
                  isDanger = true;
                  break;
              }
          }
      }

      if (isDanger) {
          DOM.dangerLine.classList.add('danger-active');
          State.dangerTimer++;
          if (State.dangerTimer > CONFIG.GAME_OVER_TIME) {
              State.isGameOver = true;
              Runner.stop(State.runner);
              DOM.finalScore.innerText = State.score;
              DOM.gameOver.style.display = 'flex';
          }
      } else {
          DOM.dangerLine.classList.remove('danger-active');
          State.dangerTimer = 0;
      }
  }

  window.onload = init;
</script>
</body>
</html>
